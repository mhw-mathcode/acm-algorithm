[题目1](https://loj.ac/p/6280)模板题，用来入门，思想其实很简单，主要是注意一下懒标记。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int,int>
#define inf 0x3f3f3f3f
const int N=5e4+5;
const int mod=998244353;
//数组a表示原数组，s表示分块后每一块要维护的值，b类似于懒标记，该块未处理的数值
int a[N],s[N],b[N];
//len表示每一块的长度，id表示该点在第几块
int len,id[N];
void add(int l,int r,int c)
{
    int sid=id[l],eid=id[r];
    //位于同一块中
    if(sid==eid)
    {
        for(int i=l;i<=r;i++) a[i]+=c,s[sid]+=c;
        return;
    }
    for(int i=l;id[i]==sid;i++) a[i]+=c,s[sid]+=c;
    for(int i=sid+1;i<eid;i++) b[i]+=c,s[i]+=len*c;
    for(int i=r;id[i]==eid;i--) a[i]+=c,s[eid]+=c;
}
int query(int l,int r,int c)
{
    int sid=id[l],eid=id[r],res=0;
    c++;
    //位于同一块中
    if(sid==eid)
    {
        for(int i=l;i<=r;i++) res=(res+a[i]+b[sid])%c;
        return res;
    }
    for(int i=l;id[i]==sid;i++) res=(res+a[i]+b[sid])%c;
    for(int i=sid+1;i<eid;i++) res=(res+s[i])%c;
    for(int i=r;id[i]==eid;i--) res=(res+a[i]+b[eid])%c;
    return res;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int n;cin>>n;
    int q=n;
    len=sqrt(n);
    for(int i=1;i<=n;i++) 
    {
        cin>>a[i];
        id[i]=(i-1)/len+1;
        s[id[i]]+=a[i];
    }
    while(q--)
    {
        int op,l,r,c;cin>>op>>l>>r>>c;
        if(op==0) add(l,r,c);
        else cout<<query(l,r,c)<<"\n";
    }
    return 0;
}
```

[题目2](https://www.luogu.com.cn/problem/P3203)貌似是LCT裸题，不知道是什么玩意，另一种做法就是分块，感觉分块题目思维量确实不小ww。


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int,int>
#define inf 0x3f3f3f3f
const int N=2e5+5;
const int mod=998244353;
//f表示i点跳几次可以跳出i所在的块，to表示i跳出所在块后的落点
int a[N],f[N],to[N];
int len,id[N],l[N],r[N];

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int n;cin>>n;
    len=sqrt(n);
    memset(l,inf,sizeof l);
    for(int i=1;i<=n;i++) 
    {
        cin>>a[i];
        id[i]=(i-1)/len+1;
        //更新i所在块的左右边界
        l[id[i]]=min(l[id[i]],i),r[id[i]]=max(r[id[i]],i);
    }
    for(int i=n;i>=1;i--)
    {
        if(i+a[i]>r[id[i]])
        {
            f[i]=1;
            to[i]=i+a[i];
        }
        else 
        {
            f[i]=f[i+a[i]]+1;
            to[i]=to[i+a[i]];
        }
    }
    int q;cin>>q;
    while(q--)
    {
        int op;cin>>op;
        if(op==1)
        {
            int j;cin>>j;j++;
            int ans=0;
            while(to[j]<=n)
            {
                ans+=f[j];
                j=to[j];
            }
            ans+=f[j];
            cout<<ans<<endl;
        }
        else 
        {
            int j,k;cin>>j>>k;j++;
            a[j]=k;
            for(int i=r[id[j]];i>=l[id[j]];i--)
            {
                if(i+a[i]>r[id[i]])
                {
                    f[i]=1;
                    to[i]=i+a[i];
                }
                else 
                {
                    f[i]=f[i+a[i]]+1;
                    to[i]=to[i+a[i]];
                }
            }
        }
    }
    return 0;
}
```

[题目3](https://www.luogu.com.cn/problem/P2801)一道洛谷蓝题，被某队长列为简单题（啊这）。有点难受，其实确实不难，但是由于我前面有个地方写错了，导致一致tle，然后我错误的认为一个正确的地方写错了……debug两小时……

```cpp
#include <bits/stdc++.h>
using namespace std;
//#define int long long
#define pii pair<int,int>
#define inf 0x3f3f3f3f
const int N=1e6+5;
const int mod=998244353;
int len,a[N],id[N],lz[N],l[N],r[N],b[N];
inline void update(int pid)
{
    int ll=l[pid],rr=r[pid];
    for(int i=ll;i<=rr;i++) b[i]=a[i];
    sort(b+ll,b+rr+1);
}
inline void add(int ll,int rr,int x)
{
    int sid=id[ll],eid=id[rr];
    if(sid==eid)
    {
        for(int i=ll;i<=rr;i++) a[i]+=x;
        update(sid);
        return;
    }
    for(int i=ll;id[i]==sid;i++) a[i]+=x;
    update(sid);
    for(int i=sid+1;i<eid;i++) lz[i]+=x;
    for(int i=rr;id[i]==eid;i--) a[i]+=x;
    update(eid);
}
int fin(int ll,int rr,int x)
{
    int pid=id[ll];
    int t=lower_bound(b+ll,b+rr+1,x-lz[pid])-b;
    return rr-t+1;
}
inline int query(int ll,int rr,int x)
{
    int sid=id[ll],eid=id[rr],res=0;
    if(sid==eid)
    {
        res+=fin(ll,rr,x);
        return res;
    }
    for(int i=ll;id[i]==sid;i++) if(a[i]>=x-lz[sid]) res++;
    for(int i=sid+1;i<eid;i++) res+=fin(l[i],r[i],x);
    for(int i=rr;id[i]==eid;i--) if(a[i]>=x-lz[eid]) res++;
    return res;
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int n,q,num=0;cin>>n>>q;
    len=sqrt(n);
    memset(l,inf,sizeof l);
    for(int i=1;i<=n;i++) 
    {
        cin>>a[i];
        id[i]=(i-1)/len+1;
        if(id[i]!=id[i-1]) num++;
        l[id[i]]=min(l[id[i]],i),r[id[i]]=max(r[id[i]],i);
    }
    for(int i=1;i<=num;i++) update(i);
    while(q--)
    {
        char op;cin>>op;
        int l,r,x;cin>>l>>r>>x;
        if(op=='M') add(l,r,x);
        else cout<<query(l,r,x)<<"\n";
    }
    return 0;
}
```

[题目4](https://loj.ac/p/6278)与上题一模一样，因为有那题经验，十分钟a掉了。代码也就不贴了。