巨重要且最常用的数据结构，难点在于要维护的值以及懒标记的下放。

按照洛谷线段树题单练。

[题目1](https://atcoder.jp/contests/abc343/tasks/abc343_f) 搓了一个上午……

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int a[N];
struct tree
{
    int l,r;
    long long pre,add;//pre表示维护的值,add表示懒标记
	int mx,mxcnt,cmx,cmxcnt;
}t[4*N+2];
void bulid(int p,int l,int r)
{
    t[p].l=l; t[p].r=r;//以p为编号的结点维护l到r
    if(l==r)//l=r的话，这个区间只有一个数
    {
        t[p].pre=a[l];
		t[p].mx=a[l];
		t[p].mxcnt=1;
		t[p].cmx=0;
		t[p].cmxcnt=0;
        return;
    }
    //否则维护的值等于左儿子加右儿子
    int mid=(l+r)>>1;
    bulid(p*2,l,mid);
    bulid(p*2+1,mid+1,r);
    //两儿子合并
	if(t[p*2].mx>t[p*2+1].mx)
	{
		t[p].mx=t[p*2].mx;
		t[p].mxcnt=t[p*2].mxcnt;
		t[p].cmx=max(t[p*2].cmx,t[p*2+1].mx);
		if(t[p*2].cmx>t[p*2+1].mx)
			t[p].cmxcnt=t[p*2].cmxcnt;
		else if(t[p*2].cmx==t[p*2+1].mx)
			t[p].cmxcnt=t[p*2].cmxcnt+t[p*2+1].mxcnt;
		else 
			t[p].cmxcnt=t[p*2+1].mxcnt;
	}
	else if(t[p*2].mx<t[p*2+1].mx)
	{
		t[p].mx=t[p*2+1].mx;
		t[p].mxcnt=t[p*2+1].mxcnt;
		t[p].cmx=max(t[p*2].mx,t[p*2+1].cmx);
		if(t[p*2].mx>t[p*2+1].cmx)
			t[p].cmxcnt=t[p*2].mxcnt;
		else if(t[p*2].mx==t[p*2+1].cmx)
			t[p].cmxcnt=t[p*2].mxcnt+t[p*2+1].cmxcnt;
		else
			t[p].cmxcnt=t[p*2+1].cmxcnt;
	}
	else
	{
		t[p].mx=t[p*2].mx;
		t[p].mxcnt=t[p*2].mxcnt+t[p*2+1].mxcnt;
		t[p].cmx=max(t[p*2].cmx,t[p*2+1].cmx);
		if(t[p*2].cmx>t[p*2+1].cmx)
			t[p].cmxcnt=t[p*2].cmxcnt;
		else if(t[p*2].cmx==t[p*2+1].cmx)
			t[p].cmxcnt=t[p*2].cmxcnt+t[p*2+1].cmxcnt;
		else
			t[p].cmxcnt=t[p*2+1].cmxcnt;
	}
} 

void change(int p,int pos,int z)
{
	int l=t[p].l,r=t[p].r;
	if(l==pos&&r==pos) 
	{
		a[l]=z;
		t[p].mx=a[l];
		t[p].mxcnt=1;
		t[p].cmx=0;
		t[p].cmxcnt=0;
		return;
	}
	int mid=(l+r)>>1;
	if(pos<=mid) change(p*2,pos,z);
	else change(p*2+1,pos,z);
	//两儿子合并
	if(t[p*2].mx>t[p*2+1].mx)
	{
		t[p].mx=t[p*2].mx;
		t[p].mxcnt=t[p*2].mxcnt;
		t[p].cmx=max(t[p*2].cmx,t[p*2+1].mx);
		if(t[p*2].cmx>t[p*2+1].mx)
			t[p].cmxcnt=t[p*2].cmxcnt;
		else if(t[p*2].cmx==t[p*2+1].mx)
			t[p].cmxcnt=t[p*2].cmxcnt+t[p*2+1].mxcnt;
		else 
			t[p].cmxcnt=t[p*2+1].mxcnt;
	}
	else if(t[p*2].mx<t[p*2+1].mx)
	{
		t[p].mx=t[p*2+1].mx;
		t[p].mxcnt=t[p*2+1].mxcnt;
		t[p].cmx=max(t[p*2].mx,t[p*2+1].cmx);
		if(t[p*2].mx>t[p*2+1].cmx)
			t[p].cmxcnt=t[p*2].mxcnt;
		else if(t[p*2].mx==t[p*2+1].cmx)
			t[p].cmxcnt=t[p*2].mxcnt+t[p*2+1].cmxcnt;
		else
			t[p].cmxcnt=t[p*2+1].cmxcnt;
	}
	else
	{
		t[p].mx=t[p*2].mx;
		t[p].mxcnt=t[p*2].mxcnt+t[p*2+1].mxcnt;
		t[p].cmx=max(t[p*2].cmx,t[p*2+1].cmx);
		if(t[p*2].cmx>t[p*2+1].cmx)
			t[p].cmxcnt=t[p*2].cmxcnt;
		else if(t[p*2].cmx==t[p*2+1].cmx)
			t[p].cmxcnt=t[p*2].cmxcnt+t[p*2+1].cmxcnt;
		else
			t[p].cmxcnt=t[p*2+1].cmxcnt;
	}
}

vector<int>q;
void query(int p,int l,int r)
{
	if(l<=t[p].l&&r>=t[p].r) 
	{
		q.push_back(p);
		return;
	}
	int mid=(t[p].l+t[p].r)>>1;
	if(l<=mid) query(p*2,l,r);
	if(r>mid) query(p*2+1,l,r); 
}

long long ask(int p,int x,int y)
{
	q.clear();
	query(p,x,y);
	int maxx=-1,cmaxx=-1;
	for(auto i:q) maxx=max(maxx,t[i].mx);
	for(auto i:q) 
		if(t[i].mx!=maxx) 
			cmaxx=max(cmaxx,t[i].mx);
	for(auto i:q) cmaxx=max(cmaxx,t[i].cmx);
	int ans=0;
	for(auto i:q)
	{
		if(t[i].mx==cmaxx) ans+=t[i].mxcnt;
		if(t[i].cmx==cmaxx) ans+=t[i].cmxcnt;
	}
	return ans;
}

int main()
{
    int n,m;cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i];
    bulid(1,1,n);
    for(int i=1;i<=m;i++)
    {
		int op; cin>>op;
		if(op==1)
		{
			int p,x;cin>>p>>x;
			change(1,p,x);
		}
        else 
		{
			int l,r;cin>>l>>r;
			cout<<ask(1,l,r)<<endl;
		}
    }
    return 0;
}
```