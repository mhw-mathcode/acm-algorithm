典型离线算法，离线下来暴力算，把$O(n^2)$优化到$O(n\sqrt{n})$.

[题目1](https://www.luogu.com.cn/problem/P2709)入门题。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int,int>
#define inf 0x3f3f3f3f
const int N=5e4+5;
const int mod=998244353;
int len,n,m,k,c;
//b是桶
int ans[N],a[N],b[N];
struct node
{
    int l,r,id;
}modui[N];
//首先按照l所在块排序，l所在块相同则按照r排序
bool cmp(node x,node y)
{
    if((x.l-1)/len==(y.l-1)/len) return x.r<y.r;
    return x.l/len<y.l/len;
}
void add(int x)
{
    c+=2*b[x]+1;
    b[x]++;
}
void del(int x)
{
    c-=2*b[x]-1;
    b[x]--;
}
void solve()
{
    cin>>n>>m>>k;
    len=sqrt(n);
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=m;i++)
    {
        int l,r;cin>>l>>r;
        modui[i]={l,r,i};
    }
    sort(modui+1,modui+m+1,cmp);
    //ans1是上次的左端点，ans2是上次的右端点
    int lef,rig,ans1=1,ans2=0;
    for(int i=1;i<=m;i++)
    {
        lef=modui[i].l,rig=modui[i].r;
        while(ans1>lef) ans1--,add(a[ans1]);
        while(ans2<rig) ans2++,add(a[ans2]);
        while(ans1<lef) del(a[ans1]),ans1++;
        while(ans2>rig) del(a[ans2]),ans2--;
        ans[modui[i].id]=c;
    }
    for(int i=1;i<=m;i++) cout<<ans[i]<<"\n";
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int T=1;//cin>>T;
    while(T--)
    {
        solve();
    }
    return 0;
}
```

[题目2](https://www.luogu.com.cn/problem/P1494)通过上面这道题，你已经学会莫队啦，快来亲手a掉这道题吧！

```cpp
//#pragma GCC optimize(2)//(据说加上o2优化快的飞起)
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int,int>
#define inf 0x3f3f3f3f
const int N=5e4+5;
const int mod=998244353;
int len,n,m,k,c;
//b是桶
int a[N],b[N],fz[N],fm[N];
struct node
{
    int l,r,id;
}modui[N];
int gcd(int a,int b)
{
    return b?gcd(b,a%b):a;
}
//首先按照l所在块排序，l所在块相同则按照r排序(一个优化)
bool cmp(node x,node y)
{
    if((x.l-1)/len^(y.l-1)/len) return (x.l-1)/len<(y.l-1)/len;
    if((x.l-1)/len&1) return x.r<y.r;
    return x.r>y.r;
}
inline void add(int x)
{
    c+=b[x];
    b[x]++;
}
inline void del(int x)
{
    b[x]--;
    c-=b[x];
}
inline void solve()
{
    cin>>n>>m;
    len=sqrt(n);
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=m;i++)
    {
        int l,r;cin>>l>>r;
        modui[i]={l,r,i};
    }
    sort(modui+1,modui+m+1,cmp);
    //ans1是上次的左端点，ans2是上次的右端点
    int lef,rig,ans1=1,ans2=0;
    for(int i=1;i<=m;i++)
    {
        lef=modui[i].l,rig=modui[i].r;
        if(lef==rig) 
        {
            fz[modui[i].id]=0,fm[modui[i].id]=1;
            continue;
        }
        while(ans1>lef) ans1--,add(a[ans1]);
        while(ans2<rig) ans2++,add(a[ans2]);
        while(ans1<lef) del(a[ans1]),ans1++;
        while(ans2>rig) del(a[ans2]),ans2--;
        int p=rig-lef+1;
        int mu=(p-1)*p/2,t=gcd(c,mu);
        fz[modui[i].id]=c/t,fm[modui[i].id]=mu/t;
    }
    for(int i=1;i<=m;i++) cout<<fz[i]<<"/"<<fm[i]<<"\n";
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int T=1;//cin>>T;
    while(T--)
    {
        solve();
    }
    return 0;
}
```